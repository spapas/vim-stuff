
Motions
-------

hjkl            Move cursor in normal mode L-D-U-R
w/W             Move to next word (or Word)
b/B             Move to previous word (or Word)
e/E             Move to end of word (or Word)
0               Move to start of line (col 0)
^               Move to first non blank character of line
$               Move to end of line
G               Move to end of file
f{char}         Find character (move to character) - forwards
F{char}         Find character (move to character) - backwards
t{char}         Find character (move before character) - forwards
T{char}         Find character (move before character) - backwards
;               For character search go to next instance of char
,               For character search go to previous instance of char
*               Find (move) to next word under cursor - forwards
#               Find (move) to next word under cursor - backwards
%               Move to matching element (parenthesis, bracket etc)
(/)             Next/previous sentence
{/}             Next/previous paragraph
H/M/L           Move to Hight / Middle / Low of screen
<c-U>/<c-D>     Move up/down (half a page)
<c-F>/<c-B>     Move forwards/backwards (a full page)
<c-O>/<c-I>     Move to previous/next position (uses the :jumps list)
``              Move to previous position

Commands
--------
i               Enter insert mode - before cursor (insert)
a               Enter insert mode - after cursor (append)
I               Enter insert mode - start of line text
A               Enter insert mode - end of line
r               Replace one character
gr              Virtual replace mode (has better behavior with tab characters)
R               Enter replace mode
gR              Enter virtual replace mode
o               Enter insert mode in new line after current 
O               Enter insert mode in new line before current 
{count}s        Delete count characters and enter insert mode (substitute)
{count}S        Delete count lines and enter insert mode
.               Repeat last change
x/X             Delete character under (before) cursor
p/P             Paste after/before cursor
J               Join two lines
ddp             Reverse two lines

Operators
---------
c{motion}       Delete selection and enter insert mode (change)
cc              Delete line and enter insert mode
d{motion}       Delete selection
dd              Delete line
y{motion}       Yank (copy) selection
yy              yank line
>{motion}       Increase identation (shift left)
>>              Increase identation of line
<{motion}       Decrease identation (shift right)
<<              Decrease identation of line
={motion}       Autoindent selection *or* filter the lines through the equalprg program
==              Autoindent line
!{motion}       Filter the lines through the executable program that is used as next argument
!!              Filter current line through the executable program that is used as next argument
gu{motion}      Switch to lowercase
guu             Switch line to lowercase 
gU{motion}      Switch to uppercase
gUU             Switch line to uppercase
g~{motion}      Swap case
g~~             Swap line case

/{pattern}      Search for pattern forwards
?{pattern}      Search for pattern backwards
n               Next match
N               Previous match

u               Undo
<C-r>           Redo

Text object selection
---------------------

Only can be used in visual mode or with an operator

{operator}a{selection}  Do operation including selection (around)
{operator}i{selection}  Do operation not including selection (inner)

Operator can be for example d (delete), c (change), etc
Selection can be w, W (w/Word), s (sentence), p (paragraph), {([<'" (to select the brackets content), t (to select html tag content)

Some examples
daw             Delete a word (works great)
diw             Delete inner word (does not work so nice because it leaves the spaces there)
caw             Change a word
ciw             Change inner word (works better because it leaves spaces there)


Ex mode
-------
<Tab>           Autocomplete
<C-d>           Show list of choices (works for cmds *and* args)

:set option     Sets the option to true
:set nooption   Sets the option to false
:set option?    Shows value of option (same as set nooption?)
:set option!    Toggle option
:so file        Source file (f.e to reload vimrc run :so $HOME/_vimrc)
:{range}delete {x} Delete range - yank to x
:{range}yank   {x} Yank range to x
:{line}put {x}      Put register x after line
:{range}copy{to}    Copy range after location to (i.e 1,5copy$) - also :t, :co
:{range}move{to}    Move range after location to - also :m, :mo
:{range}join (:j)   Join lines
:{range}normal      Execute normal commands (f.e :%norm A; to insert semicolon after end of all lines) - also :norm
:{range}substitute  Replace - see examples below - also :s
:!{command}     Execute command with shell 
:{range}!{command}  Pass range to command (the {motion}! command is a shortcut for this)
:read               Insert file contents to current file (notice that you can use something like :read !{command})
:retab              Fix tabs (add ! to also change spaces)
:jumps              Display jumps list

:{range}global{patter}{cmd}   For lines in range that match pattern execute cmd. To negate use :v or :g!. For example to delete blank lines
- g/^\s*$/d 
or
- g/^\s*$/norm dd (norm executes the normal command dd for each line)


:%s/p1/p2/g     Replace pattern p1 with p2. The %s matches all lines in document, the g substitutes all patters in the line
:%s/\%u200b//g  Replace special character using its Unicode value


:tabnew         Open new tab
:split/vsplit   Split pane horizontal/vertical (also use :sp or :vs)
:edit (:e) {f}  Edit file f
:edit! (:e!)    Reload current file discarding changes
:write (:w)     Write file (filename is optional)
:wnext (:wn)    Write file and go to next buffer
:wall           Save every buffer
:ls             List buffers
:bnext          Next buffer - :bn
:bprev          Previous buffer - :bp
:bdelete        Remove buffer :bd (does not delete file) - it takes arguments f. e :1,5bd or :bd 1 3 5
:args           Show arguments (files passed as parameter to vim) - can be modified. Can use globs or backtip expansion.
:argdo          Execute command for all arguments - f.e :argdo %p
:first, :next, :previous, :last     Move around in list of arguments

<C-h>           Backspace
<C-w>           Delete word
<C-u>           Delete line
<C-[>           Switch to normal (like ESC)
<C-r>{register} Paste text (register you have yanked to with " - use 0 for the most recent edit)
<C-r><C-w>      Put word from text to command line
<C-r><C-a>      Put Word from text to command line
<C-f>           Open command line window

Ex mode ranges
--------------
.               Current line
$               Last line
1               First line
%               All lines
.,$             Range from here until end
+5,+10          Relative ranges (from current)
/patter1/,/pattern2/    Range by patterns
'{mark}         Line with mark

Macros
------

q{register}     Start macro capturing - stops capturing again with q
@{register}     Replay macro of register
@:              Replay last ex command
@@              Replay lat macro

Insert mode commands
--------------------

<C-h>           Backspace
<C-w>           Delete word
<C-u>           Delete line
<C-[>           Switch to normal (like ESC)
<C-o>           Switch to insert-normal mode
<C-r>{register} Paste text (register you have yanked to with " - use 0 for the most recent edit)
<C-k>{l1}{l2}   Insert digraph (f.e << or 14 or DG)
<C-v>{chars}    Insert character using numeric value. Use uHex to insert unicode symbol, f.e <C-v>u20ac inserts €.

Registers
---------

0               Most recent
*               System (unless you have remapped it to the unnamed)
"               Unnamed
_               Void (does not yank to anywhere)
.               Last inserted text
%               Filename
:               Most recent executed ex command
=               Expression register (opens prompt to do math)
/               Last search pattern

To write a register use :let @/ = "foo"

Visual mode
-----------

v               Enable
V               Enable line-visual mode
gv              Re-select last selection (also works from normal mode)
<c-v>           Εnable block-visual mode
<C-g>           Switch to select mode
o               Go to other end of selection

Other commands
--------------

q:              Open command line window

Using windows / Splits
----------------------

:vsplit or :vs or <C-w><C-v> or <C-w>v      Vertical Split
:split or :sp or <C-w><C-s> or <C-w>s       Horizontal Split
:split or :vsplit also take a filename to open the file to split directly
For CtrlP you can use <C-v> or <C-s> on the selected file to open it to split
<C-w>w or <C-w><C-w>                        Cycle buffer focus
<C-w>hjkl or <C-w><C-hjkl>                  Move focus to L D U R split
:close or :clo or :q or :quit or <C-w>c or <C-w><C-c> or <C-w>q or <C-w><C-q>       Close/quit window
check out this https://vi.stackexchange.com/questions/9479/what-is-the-difference-between-quit-and-close-commands for their difference-between-quit-and-close-commands
:only or :on or <C-w>o or <C-w><C-o>        Make current window the only one on screen - close all others
:<C-w>=                                     Make windows equal
:<C-w>+                                     Increase window size (can take number in front)
:<C-w>-                                     Decrease window size (can take number in front)

Some options
------------

:set spell              To enable spell checking - move to errors with ]s and
[s, z= display suggestions, 1z= replace with first suggestion, zg mark as 
correct, zw mark as misspelled
:set ft                 To set the filetype to something else


Folds
-----

zM                      Fold everything
zR                      Unfold everything
zm                      Increase global folding level 
zr                      Reduce global folding level
zf{motion}              Create a manual fold
zc/zo                   Close/open a local fold
za/zA                   Open (if closed) or close (if opened) a local fold - zA is recursive
zx                      Reset fold to foldlevel
:set foldlevel          Default foldlevel - 0 = all folded (zM sets it to 0, zR to maximum)


Pattern tips
------------
/\Mpattern              Search with less magic (i.e \M. will search for .)
/\Vpattern              Search with even less magic (i.e \V$ will search for $)

