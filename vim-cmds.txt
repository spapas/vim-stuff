
Motions
-------

hjkl            Move cursor in normal mode L-D-U-R
gj/gk           Move cursor D-U on display line
w/W             Move to next word (or Word)
b/B             Move to previous word (or Word)
e/E             Move to end of word (or Word)
ge/gE           Move to end of *previous* word (or Word)
0               Move to start of line (col 0) - g0 to start of display line
^               Move to first non blank character of line - g^ for display line
$               Move to end of line - g$ for display line
G               Move to end of file
f{char}         Find character (move to character) - forwards
F{char}         Find character (move to character) - backwards
t{char}         Find character (move before character) - forwards
T{char}         Find character (move before character) - backwards
;               For character search go to next instance of char
,               For character search go to previous instance of char
*               Find (move) to next word under cursor - forwards
#               Find (move) to next word under cursor - backwards
%               Move to matching element (parenthesis, bracket etc)
(/)             Next/previous sentence
{/}             Next/previous paragraph
H/M/L           Move to Hight / Middle / Low of screen
<c-U>/<c-D>     Move up/down (half a page)
<c-F>/<c-B>     Move forwards/backwards (a full page)
``              Move to previous position
`.              Move to previous change
`^              Move to previous insertion
`{mark}         Move to mark - row and column
'{mark}         Move to mark - only row

Jumps
-----

Notice these cannot be used as motions

<c-O>/<c-I>     Jump to previous/next position (uses the :jumps list)
g;/g,           Jump to older / newer change (uses the :changes list)
gi              Jump to last insert
gf              Jump to filename under cursor (try vimrc)

Commands
--------
i               Enter insert mode - before cursor (insert)
a               Enter insert mode - after cursor (append)
I               Enter insert mode - start of line text
A               Enter insert mode - end of line
r               Replace one character
gr              Virtual replace mode (has better behavior with tab characters)
R               Enter replace mode
gR              Enter virtual replace mode
o               Enter insert mode in new line after current 
O               Enter insert mode in new line before current 
{count}s        Delete count characters and enter insert mode (substitute)
{count}S        Delete count lines and enter insert mode
.               Repeat last change
x/X             Delete character under (before) cursor
p/P             Paste after/before cursor
gp/gP           Paste after/before cursor moving the cursor to the end of the text
J               Join two lines
m{mark}         Set mark - lower case are local to file, Uppercase are global


Useful combinations
-------------------
ddp             Reverse two lines
yyp             Duplicate line
xp              Reverse two characters
ea              Append at end of current word
gea             Append at end of previous word
dt.             Delete until end of sentence - do not include .
df.             Delete until end of sentence - including .
``              Move to previous position
`"              Goto last position (uses mark)
`.              Goto last change (uses mark)
`^              Goto last insertion (uses mark)
`~, `~          Goto start/end of last visual selection (uses mark)
VG              Visually select all lines from here to the end
ggVG            Visually select all lines of file

Lesser commands
---------------
<C-g>           Show file status
zz              Center screen on current line

Operators
---------
c{motion}       Delete selection and enter insert mode (change)
cc              Delete line and enter insert mode
d{motion}       Delete selection
dd              Delete line
y{motion}       Yank (copy) selection
yy              yank line
>{motion}       Increase identation (shift left)
>>              Increase identation of line
<{motion}       Decrease identation (shift right)
<<              Decrease identation of line
={motion}       Autoindent selection *or* filter the lines through the equalprg program
==              Autoindent line
!{motion}       Filter the lines through the executable program that is used as next argument
!!              Filter current line through the executable program that is used as next argument
gu{motion}      Switch to lowercase
guu             Switch line to lowercase 
gU{motion}      Switch to uppercase
gUU             Switch line to uppercase
g~{motion}      Swap case
g~~             Swap line case

/{pattern}      Search for pattern forwards
?{pattern}      Search for pattern backwards
n               Next match
N               Previous match

u               Undo
<C-r>           Redo

Text object selection
---------------------

Only can be used in visual mode or with an operator

{operator}a{selection}  Do operation including selection (around)
{operator}i{selection}  Do operation not including selection (inner)

Operator can be for example d (delete), c (change), etc
Selection can be w, W (w/Word), s (sentence), p (paragraph), {([<'" (to select the brackets content), t (to select html tag content)

Some examples
daw             Delete a word (works great)
diw             Delete inner word (does not work so nice because it leaves the spaces there)
caw             Change a word
ciw             Change inner word (works better because it leaves spaces there)


Ex mode
-------
<Tab>           Autocomplete
<C-d>           Show list of choices (works for cmds *and* args)

:set option     Sets the option to true
:set nooption   Sets the option to false
:set option?    Shows value of option (same as set nooption?)
:set option!    Toggle option
:so file        Source file (f.e to reload vimrc run :so $HOME/_vimrc)
:{range}delete {x} Delete range - yank to x
:{range}yank   {x} Yank range to x
:{line}put {x}      Put register x after line
:{range}copy{to}    Copy range after location to (i.e 1,5copy$) - also :t, :co
:{range}move{to}    Move range after location to - also :m, :mo
:{range}join (:j)   Join lines
:{range}normal      Execute normal commands (f.e :%norm A; to insert semicolon after end of all lines) - also :norm
:{range}substitute  Replace - see examples below - also :s
:!{command}     Execute command with shell 
:{range}!{command}  Pass range to command (the {motion}! command is a shortcut for this)
:read               Insert file contents to current file (notice that you can use something like :read !{command})
:retab              Fix tabs (add ! to also change spaces)
:jumps              Display jumps list
:register           Display registers (takes also parameters) - :reg
:changes            Display changes list
:pwd                Print current directory
:file               Opens a file (uses path for autocomplete)


:{range}global{patter}{cmd}   For lines in range that match pattern execute cmd. To negate use :v or :g!. For example to delete blank lines
- g/^\s*$/d 
or
- g/^\s*$/norm dd (norm executes the normal command dd for each line)


:%s/p1/p2/g     Replace pattern p1 with p2. The %s matches all lines in document, the g substitutes all patters in the line
:%s/\%u200b//g  Replace special character using its Unicode value


:tabnew         Open new tab
:split/vsplit   Split pane horizontal/vertical (also use :sp or :vs)
:edit (:e) {f}  Edit file f
:edit! (:e!)    Reload current file discarding changes
:write (:w)     Write file (filename is optional)
:wnext (:wn)    Write file and go to next buffer
:wall           Save every buffer
:ls             List buffers
:bnext          Next buffer - :bn
:bprev          Previous buffer - :bp
:bdelete        Remove buffer :bd (does not delete file) - it takes arguments f. e :1,5bd or :bd 1 3 5
:args           Show arguments (files passed as parameter to vim) - can be modified. Can use globs or backtip expansion.
:argdo          Execute command for all arguments - f.e :argdo %p
:first, :next, :previous, :last     Move around in list of arguments

Shortcust in Ex mode
--------------------
<C-h>           Backspace
<C-w>           Delete word
<C-u>           Delete line
<C-[>           Switch to normal (like ESC)
<C-r>{register} Paste text (register you have yanked to with " - use 0 for the most recent edit)
<C-r><C-w>      Put word from text to command line
<C-r><C-a>      Put Word from text to command line
<C-f>           Open command line window
<C-b>           Cursor to begin of command-line
<C-e>           Cursor to end   of command-line
<C-f>           Opens the command-line window (unless a different key is specified in 'cedit')
<C-p>           Recall previous command-line from history (that matches pattern in front of the cursor)
<C-n>           Recall next     command-line from history (that matches pattern in front of the cursor)
<Up>            Recall previous command-line from history (that matches pattern in front of the cursor)
<Down>          Recall next     command-line from history (that matches pattern in front of the cursor)
<S-Up>          Recall previous command-line from history
<S-Down>        Recall next     command-line from history
<PageUp>        Recall previous command-line from history
<PageDown>      Recall next     command-line from history
<S-Left>        Cursor one word left
<C-Left>        Cursor one word left
<S-Right>       Cursor one word right
<C-Right>       Cursor one word right

<LeftMouse>  cursor at mouse click

Ex mode ranges
--------------
.               Current line
$               Last line
1               First line
%               All lines
.,$             Range from here until end
+5,+10          Relative ranges (from current)
/patter1/,/pattern2/    Range by patterns
'{mark}         Line with mark

Macros
------

q{register}     Start macro capturing - stops capturing again with q. Write register in CAPS to append in the end of the existing macro
@{register}     Replay macro of register
@:              Replay last ex command
@@              Replay lat macro

Insert mode commands
--------------------

<C-h>           Backspace
<C-w>           Delete word
<C-u>           Delete line
<C-[>           Switch to normal (like ESC)
<C-o>           Switch to insert-normal mode
<C-r>{register} Paste text (register you have yanked to with " - use 0 for the most recent edit)
<C-k>{l1}{l2}   Insert digraph (f.e << or 14 or DG)
<C-v>{chars}    Insert character using numeric value. Use uHex to insert unicode symbol, f.e <C-v>u20ac inserts €.

Registers
---------

0               Most recent yank
+/*               System (unless you have remapped it to the unnamed)
"               Unnamed
_               Void / black hole (does not yank to anywhere)
.               Last inserted text
%               Filename
#               Alternate filename (full path in Windows)
:               Most recent executed ex command
=               Expression register (opens prompt to do math)
/               Last search pattern

To write a register use :let @/ = "foo"

Visual mode
-----------

v               Enable
V               Enable line-visual mode
gv              Re-select last selection (also works from normal mode)
<c-v>           Εnable block-visual mode
<C-g>           Switch to select mode
o               Go to other end of selection

Other commands
--------------

q:              Open command line window

Using windows / Splits
----------------------

:vsplit or :vs or <C-w><C-v> or <C-w>v      Vertical Split
:split or :sp or <C-w><C-s> or <C-w>s       Horizontal Split
:split or :vsplit also take a filename to open the file to split directly
For CtrlP you can use <C-v> or <C-s> on the selected file to open it to split
<C-w>w or <C-w><C-w>                        Cycle buffer focus
<C-w>hjkl or <C-w><C-hjkl>                  Move focus to L D U R split
:close or :clo or :q or :quit or <C-w>c or <C-w><C-c> or <C-w>q or <C-w><C-q>       Close/quit window
check out this https://vi.stackexchange.com/questions/9479/what-is-the-difference-between-quit-and-close-commands for their difference-between-quit-and-close-commands
:only or :on or <C-w>o or <C-w><C-o>        Make current window the only one on screen - close all others
<C-w>=                                      Make windows equal
<C-w>+                                      Increase window size (can take number in front)
<C-w>-                                      Decrease window size (can take number in front)

<C-w>T                                      Open current split to new tab
:tabedit                                    Open new tab (takes filename) - :tabe 
:tabclose                                   Close tab - :tabc 
:tabonly                                    Close other tabs - :tabo 
gt                                          Next tab - :tabn, :tabnext - also takes tab number as argument
gT                                          Previous tab - :tabp, :tabprevious



Some options
------------

:set spell              To enable spell checking - move to errors with ]s and
[s, z= display suggestions, 1z= replace with first suggestion, zg mark as 
correct, zw mark as misspelled
:set ft                 To set the filetype to something else
:set path               To set the searching path (initially it is current directory) - can use globs to search recursively, also works with gf
:set sufficesadd        List of suffixes (file extensions) to try when opening files with gf

Folds
-----

zM                      Fold everything
zR                      Unfold everything
zm                      Increase global folding level 
zr                      Reduce global folding level
zf{motion}              Create a manual fold
zc/zo                   Close/open a local fold
za/zA                   Open (if closed) or close (if opened) a local fold - zA is recursive
zx                      Reset fold to foldlevel
:set foldlevel          Default foldlevel - 0 = all folded (zM sets it to 0, zR to maximum)


Pattern tips
------------
/\Mpattern              Search with less magic (i.e \M. will search for .)
/\Vpattern              Search with even less magic (i.e \V$ will search for $)

Netrw
-----

:Explore                Show explorer from current buffer - :Exp
:e.                     Show explorer from current directory
:e directory            Show explorer from directory
:Sexplore               Show explorer in (horz) split - :Sex
:Vexplore               Show explorer in vertical split - :Vex

